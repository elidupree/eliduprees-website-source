## I put old scratchpad contents in this file, so that that file can remain small without me deleting my data






import math

cardboard_width = 0.06
padding_width = 3/8;


box_length = 5.75
box_width = 4.72 #4.75
box_outer_length = box_length + cardboard_width*2
box_outer_width = box_width + cardboard_width*2

fan_depth = 1
fan_outer_width = 4.72
fan_inner_width = 4.5
fan_inner_radius = fan_inner_width/2

filter_depth = 0.5
filter_outer_length = 5.75
filter_outer_width = 3+15/16
filter_border = 3/16
filter_inner_length = filter_outer_length - filter_border*2
filter_inner_width = filter_outer_width - filter_border*2
filter_grip_width = (box_width - filter_inner_width)/2

filter_placement = (box_width - filter_outer_width)/2
fan_placement = (box_length - fan_outer_width)/2

support_depth = 0.5

box_depth = support_depth + cardboard_width + fan_depth + cardboard_width + filter_depth

head_width = 6+3/8
head_length = 7+5/8
head_circumference = 22

turn = math.pi*2

next_id = 40000
close = "z"

def draw_path (path):
  first = "M"
  components = []
  for location in path:
    if location == "z":
      components.append ("z")
      first = "M"
    else:
      #convert in to pt and position within bounds
      components.append (first + " " + str (location [0]*72 + 14.173) + " " + str (location [1]*72 + 14.173))
      first = "L"
  global next_id
  next_id = next_id + 1
  return '''<path
       style="opacity:1;fill:none;fill-opacity:1;fill-rule:nonzero;stroke:#0000ff;stroke-width:0.0283465;stroke-linecap:butt;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
       d="'''+ " ".join (components) +''' "
       id="'''+ str (next_id) +'''" />'''

def split_path (path):
  previous = None
  components = []
  origin = None
  for location in path:
    #print (location, origin)
    if location == close:
      components.append ([previous, origin])
      origin = None
      previous = None
    else:
      if previous is not None:
        components.append ([previous, location])
      previous = location
      if origin is None:
        origin = location
  return components

def perforated (component):
  vertex = (component [1] [0] - component [0] [0], component [1] [1] - component [0] [1])
  distance = math.sqrt (vertex [0]*vertex [0] + vertex [1]*vertex [1])
  perforation_length = 1/8
  segments = math.floor (distance/perforation_length)
  increment = segments*2 + 1
  result = []
  for index in range (segments):
    factor_1 = (index*2 + 1)/increment
    factor_2 = (index*2 + 2)/increment
    result.append ([
      (component [1] [0] - vertex [0]*factor_1, component [1] [1] - vertex [1]*factor_1),
      (component [1] [0] - vertex [0]*factor_2, component [1] [1] - vertex [1]*factor_2)
    ])
  return result
  
def translate_path (path, horizontal, vertical):
  for index in range (len (path)):
    if type (path [index]) is tuple:
      path [index] = (path [index] [0] + horizontal, path [index] [1] + vertical)
      
def flip_path (path):
  for index in range (len (path)):
    if type (path [index]) is tuple:
      path [index] = (path [index] [0], -path [index] [1])

def rectangle_center (first, second, width, height):
  first = first + horizontal_default
  second = second + vertical_default
  return [(first - width/2, second - height/2), (first + width/2, second - height/2), (first + width/2, second + height/2), (first - width/2, second + height/2), close]

vertical_default = 0
def rectangle_advance_vertical (first, second, width, height):
  global vertical_default
  result = rectangle_corner(first, second, width, height)
  vertical_default = vertical_default + height
  return result
horizontal_default = 0
def rectangle_advance_horizontal (first, second, width, height):
  global horizontal_default
  result = rectangle_corner(first, second, width, height)
  horizontal_default = horizontal_default + width
  return result

def rectangle_corner (first, second, width, height):
  first = first + horizontal_default
  second = second + vertical_default
  return [(first, second), (first + width, second), (first + width, second + height), (first, second + height), close]

def oval (first, second, width, height, segments, parity, inscribed):
  first = first + horizontal_default
  second = second + vertical_default
  inaccuracy = 1 if inscribed else math.cos (turn*0.5/segments);
  result = []
  for index in range (0, segments):
    angle = turn*(index + parity)/segments
    result.append ((first + width*math.cos (angle)/inaccuracy, second + height*math.sin (angle)/inaccuracy))
  result.append (close)
  return result
  
paths = [
  #rectangle_corner (0, 0, box_width + box_length + box_width + box_length, box_depth),
  [(0, 0), (0, box_depth + filter_grip_width), (box_length, box_depth + filter_grip_width), (box_length, box_depth), (box_length + box_width, box_depth), (box_length + box_width, box_depth + filter_grip_width),(box_length + box_width + box_length, box_depth + filter_grip_width),(box_length + box_width + box_length, box_depth), (box_length + box_width + box_length + box_width, box_depth), (box_length + box_width + box_length + box_width, 0), close],
]

band_depth = 1
air_width = 1
brim_min_width = 2

hat_top = []
hat_brim = []
hat_band = [rectangle_advance_vertical (0, 0, head_circumference + turn*padding_width, band_depth)]


#flip_path (paths [0])
#translate_path (paths [0], 0, box_depth + filter_grip_width)
translate_path (paths [0], 0, vertical_default)

horizontal_default = 0
vertical_default = vertical_default + box_depth + filter_grip_width
long_position = vertical_default


supports = [
  rectangle_advance_vertical (0, 0, box_length, support_depth),
  rectangle_advance_vertical (0, 0, box_length, support_depth),
  
  #the other supports aren't strictly needed. However:
  # – supports in the filter allow you to run it without the filter, like for cooling
  # – supports in the fan area allow you to run it without the fan, like if you have some other source of airflow
  # – having ALL the supports means that the gates can stay in place even when the components aren't there, such as during construction and if you temporarily removed them to use for something else.
  
  rectangle_advance_vertical (0, 0, box_length, fan_depth - cardboard_width),
  rectangle_advance_vertical (0, 0, box_length, fan_depth - cardboard_width),
   
  rectangle_advance_vertical (0, 0, box_length, filter_depth - cardboard_width),
  rectangle_advance_vertical (0, 0, box_length, filter_depth - cardboard_width),
]

horizontal_default = box_length
vertical_default = long_position
placements = [
  rectangle_advance_horizontal (0, 0, fan_placement, box_width),
  rectangle_advance_horizontal (0, 0, fan_placement, box_width),
  rectangle_advance_horizontal (0, 0, filter_placement, box_length),
  rectangle_advance_horizontal (0, 0, filter_placement, box_length),
]

gates = [
  oval (box_width/2, box_length/2, fan_inner_width/2, fan_inner_width/2, 8, 0.5, False)[-2::-1] + [close] + rectangle_advance_horizontal (0, 0, box_width, box_length),
  rectangle_center (box_width/2, box_length/2, filter_inner_width, fan_inner_width)[-2::-1] + [close] + rectangle_advance_horizontal (0, 0, box_width, box_length),
]


brim_segments = 24
for index in range (brim_segments + 1):
  angle = turn*(index)/brim_segments
  vertex = (
    (head_width /2 + padding_width + cardboard_width)*math.cos (angle),
    (head_length/2 + padding_width + cardboard_width)*math.sin (angle)
  )
  distance = math.sqrt (vertex [0]*vertex [0] + vertex [1]*vertex [1])
  cut_factor = (distance - band_depth)/distance
  cut_vertex = (vertex [0] * cut_factor, vertex [1] * cut_factor)
  bonus_factor = 1 - abs (angle - (turn/4))/(turn/8)
  bonus_vertex = None
  if bonus_factor >0:
    bonus_vertex_factor = ((distance + air_width * bonus_factor)/distance)
    bonus_vertex = (vertex [0] * bonus_vertex_factor, vertex [1] * bonus_vertex_factor)
  
  if index > 0:
    hat_brim.append ([vertex, cut_vertex])
    hat_brim.append ([cut_vertex, previous_cut_vertex])
    hat_brim.extend (perforated ([vertex, previous_vertex]))
    hat_top.append ([
      vertex if bonus_vertex is None else bonus_vertex,
      previous_vertex if previous_bonus_vertex is None else previous_bonus_vertex
    ])
    if (bonus_vertex is not None) and (previous_bonus_vertex is not None):
      factor_1 = 0.8
      factor_2 = 0.2
      endpoint_1 = (bonus_vertex [0]*factor_1 + previous_bonus_vertex [0]*factor_2,
                    bonus_vertex [1]*factor_1 + previous_bonus_vertex [1]*factor_2)
      endpoint_2 = (previous_bonus_vertex [0]*factor_1 + bonus_vertex [0]*factor_2,
                    previous_bonus_vertex [1]*factor_1 + bonus_vertex [1]*factor_2)
      midpoint_1 = (vertex [0]*factor_1 + previous_bonus_vertex [0]*factor_2,
                    vertex [1]*factor_1 + previous_bonus_vertex [1]*factor_2)
      midpoint_2 = (previous_vertex [0]*factor_1 + bonus_vertex [0]*factor_2,
                    previous_vertex [1]*factor_1 + bonus_vertex [1]*factor_2)
      hat_brim.append ([endpoint_1, midpoint_1])
      hat_brim.append ([midpoint_1, midpoint_2])
      hat_brim.append ([midpoint_2, endpoint_2])
      hat_brim.extend (perforated ([endpoint_1, endpoint_2]))
  
  previous_angle = angle
  previous_vertex = vertex
  previous_cut_vertex = cut_vertex
  previous_bonus_vertex = bonus_vertex

for whatever in hat_brim:
  flip_path (whatever)
  translate_path (whatever, 31 - head_width/2 - padding_width - cardboard_width - brim_min_width, 15 - head_length/2 - padding_width - cardboard_width - brim_min_width)

for whatever in hat_top:
  flip_path (whatever)
  translate_path (whatever, 31 - head_width*1.5 - brim_min_width*2 - (padding_width + cardboard_width)*3, 15 - head_length/2 - padding_width - cardboard_width)

diagonal = []
horizontal = []
vertical = []

for path in (paths + supports + placements + gates + hat_top + hat_brim + hat_band):
  for component in split_path (path):
    (horizontal if component[0] [1] == component[1] [1] else vertical if component[0] [0] == component[1] [0] else diagonal).append (component)


for (list, equal_dimension, different_dimension) in [(horizontal, 1, 0), (vertical, 0, 1)]:
  for index in range (len (list)):
    if list[index] [0] [different_dimension] >list[index] [1] [different_dimension]:
      list[index] = (list[index] [1], list[index] [0])
  
  list.sort (key = lambda component: component [0] [equal_dimension] + 0.00001*component [0] [different_dimension])
    
  index = 0
  while index <len (list) - 1:
    if abs(list[index] [0] [equal_dimension] - list [index + 1] [0] [equal_dimension]) < 0.0001 and list [index] [1] [different_dimension] >= -0.0001 + list [index + 1] [0] [different_dimension]:
      removed = list.pop (index + 1)
      if removed [1] [different_dimension] >list [index] [1] [different_dimension]:
        list [index] = (list [index] [0], removed [1])
    else:
      index = index + 1
      


#TODO: add tabs to enclosure; add folding lines; design hat; secure grip for purifier in hat so it needn't stick up; optimize; fix bug
print ("\n".join ([draw_path (path) for path in (horizontal + vertical + diagonal)]))





string ='''

'''

index = 0
def transform (match):
  nonlocal index
  if match.group (0) == "voldemort's":
    index = index + 1
    return match.group (0)
  else:
    return "voldemorts-children/" +str (index)
  
import re
print (re.sub (r"voldemort's|voldemorts-children/\d+", transform, string ))



import shutil
import re
import subprocess

with open ("./game.svg", "r") as file:
  text = file.readall ()
  text_identifiers = [match.group (1) for match in re. finditer (r'''<text.*?id=".+?)".*?(?<!>R|>L)</tspan></text>''')]
shutil.copy ("./game.svg", "./without_text.svg")
shutil.copy ("./game.svg", "./with_only_text.svg")

subprocess.run (["inkscape", "./without_text.svg"] + ["--select=" + ID for ID in text_identifiers] + ["--verb=EditDelete","--verb=FileSave"])
subprocess.run (["inkscape", "./with_only_text.svg"] + ["--select=" + ID for ID in text_identifiers] + ["--verb=EditInvert","--verb=EditDelete","--verb=FileSave"])


global fake_comment_id
fake_comment_id = ''
def put_in_hover_boxes(comment_list):
  if len(comment_list) == 0:
    return ''
  global fake_comment_id
  fake_comment_id = fake_comment_id+'i'
  return '<div class="comment_hover_box"><div class="whole_comment_hover_marker">'+comment_list[0]+'</div>'+put_in_hover_boxes(comment_list[1:])+'</div>'

def fake_comments(tree_structure):
  return put_in_hover_boxes(['<article><div class="user_comment" id='+fake_comment_id+'><div class="comment_body_hover_marker"><div class="comment_body_outer"><div class="comment_body"><h3>SomeUser5098 <a href="#'+fake_comment_id+'">wrote</a>:</h3>I GOT STUFF TO SAY</div></div></div>'+fake_comments(foo)+'</div></article>' for foo in tree_structure])

fake_comment_html = '''<section>
  <div class="comments_section">
    <h2 class="comments_title">Comments</h2>
    <div class="all_comments">'''+fake_comments([[[],[[[],[[[]],[]],[]]]],[],[[[],[[[],[[[]],[]],[]]]]]])+'''</div>
  </div>
</section>'''
  
def add_fake_comments(html):
  return re.sub(re.escape(utils.inline_separator+'<a href="">Comments&nbsp;(14)</a>'), fake_comment_html, html)




codecophony:

main thread:
only this thread can interact with the UI.
Only this thread can interact with web audio.
Forbidden from cloning large arrays to or from other threads or indexedDB, although it may transfer them with other threads.
Records audio input, and also clone-messages it live (incrementally, in small chunks) to Trusted Worker.
The UI gives information about tasks that have been allocated to other threads and not yet completed.

Trusted Worker:
Able to interact with indexedDB.
New audio buffers are sent here to be analyzed/rendered; analysis is sent incrementally to the main thread to be shown to the user
Answers requests from Sandbox Worker for stuff from indexedDB.
Fetches MIDIJS instruments and stores them in indexedDB.

Sandbox Worker:
runs user scripts.

render_notes:
first iterates through the notes, requesting all instruments and sorting them by start time.
Incrementally transfers the rendered audio to Trusted Worker for analysis.
You may specify a "focal time" to begin the rendering at, so that you can get prompt updates if you're tweaking the middle of a long piece of music. Also maybe we should be more incremental in general? Render_notes could examine the previous collection of notes and only re-render parts that have changed. The "focal time" feature is still useful if you, say, transpose the entire piece.



"invariants" (things which should become true if you leave the scripts alone long enough to do them):
manually created user data is in indexedDB
MIDIJS instruments which are referenced by any project are in indexedDB
MIDIJS instruments which are NOT referenced by any project are NOT in indexedDB
the UI reflects the data in indexedDB










var notes = [];
for (var whatever = 0; whatever <100;++whatever) {
  notes.push ({
    start: Math.floor (Math.random()*30)/3,
    duration: Math.random()*0.4 + 0.2,
    pitch: Math.floor (Math.random()*12)-6,
    instrument: "trumpet",
    volume: 1,
  });
}
items.optimize (notes, {change_leeway:2, iterations:510, interval_quality:
  function (interval, imperfection, first, second) {
    var center = (first.start + second.start)/2;
    var target = 11 - center;
    var reward = -Math.abs (interval.limit - target)*Math.abs (interval.limit - target);
    return reward - imperfection;
  }
});
items.example_notes = notes;

var example_sequence = items.example_sequence = codecophony.render_notes (notes);



var notes = codecophony.scrawl (
  `with instrument trumpet pitch -10 duration 0.28 change_leeway 1.015

play 0 then 2 then 3 then 5 then 7 then 8 then 10 then 12
then 0 then 2 then 3 then 5 then 7 then 8 then 10 then 12
then 0 then 2 then 3 then 5 then 7 then 8 then 10 then 12
then 0 then 2 then 3 then 5 then 7 then 8 then 10 then 12

`
)
for (var scale = 1; scale <32;scale*=2) {
  for (var position = 0; position <32; position += scale) {
    notes.push ({
      start: position/4,
      duration: scale/4,
      pitch: 0,//Math.floor (Math.random()*12)-6,
      instrument: "trumpet",
      volume: 0.2,
    });
  }
}

items.optimize (notes, {change_leeway:2, iterations:510,interval_quality: function (interval, imperfection, first, second) {
      var overlapping = (first.start <second.start + second.duration - 0.2) && (second.start <first.start + first.duration - 0.2);
      var badness = interval.limit;
      
      if (overlapping) {
        badness = badness*badness;
        imperfection *= 20;
      }
else if (badness == 9 || badness == 17) {
badness = -10
}
if (interval.limit === 1) {badness = 7999999;}
      var result =-imperfection - badness;
      return result*first.volume*second.volume;
    }
});
items.example_notes3 = notes;

var example_sequence = items.example_sequence3 = codecophony.render_notes (notes);





var reference_intervals = [];

// inefficient algorithm to generate the lookup table
// specifically, we want to be able to look up, for any interval, the interval with the smallest odd-limit that is within the just-noticeable-difference (about 0.6%, according to Wikipedia) of the query.

var JND = 1.006;
var semitone_ratio = Math.pow (2, 1/12) ;

function closest_intervals_impl (frequency) {
  var index =_.sortedIndexBy (reference_intervals, {frequency}, (interval) => interval.frequency);
  var previous = reference_intervals [index - 1];
  var next = reference_intervals [index];
  
  if (!previous) {previous = {limit: 1, numerator: 1, denominator: 1, frequency: 1.0};}
  if (!next) {next = {limit: 1, numerator: 1, denominator: 1, frequency: 2.0};}
  
  return {index, previous, next};
}

var limit = 3;
while (limit < 40) {
  var done = reference_intervals.length >0;
  reference_intervals.forEach(function(interval, index) {
    var next = reference_intervals [index + 1];
    if (next && next.frequency > interval.frequency*JND*JND) {done = false;}
    if (!next && 2.0 > interval.frequency*JND*JND) {done = false;}
  });
  if (done) {break;}
  
  
  function consider (limit, numerator, denominator) {
    var frequency = numerator/denominator;
    while (frequency <1.0) {frequency *= 2;}
    while (frequency >2.0) {frequency /= 2;}
    var interval = {limit, numerator, denominator, frequency};
    
    var nearby = closest_intervals_impl (frequency);
    
    // try not to duplicate intervals by ruling out ones that are VERY close
    // I could instead rule out intervals that are not introduced form, but I can't bother
    if (nearby.previous.frequency*1.00001 > frequency && frequency*1.00001 > nearby.previous.frequency) {return;}
    if (nearby.next.frequency*1.00001 > frequency && frequency*1.00001 > nearby.next.frequency) {return;}
    
    //rule out intervals that are already in the shadow of others
    if (nearby.next.frequency < nearby.previous.frequency*JND*JND) {return;}
      
    reference_intervals.splice (nearby.index, 0, interval);
  }
  for (var other = 1; other <= limit; other += 2) {
    consider (limit, limit, other);
    consider (limit, other, limit);
  }
  
  limit += 2;
}

function closest_interval (frequency) {
  while (frequency <1.0) {frequency *= 2;}
  while (frequency >2.0) {frequency /= 2;}
  
  var nearby = closest_intervals_impl (frequency);
  if (frequency/nearby.previous.frequency < nearby.frequency/frequency) {
    return nearby.previous;
  }
  else {
    return nearby.next;
  }
}

function note_frequency (note) {
  return 261.626 * Math.pow (2, note.pitch / 12) * (note.speed || 1);
}

function optimize (notes, extras) {
  if (!extras) {extras={};}
  if (extras.neighbor_leeway === undefined) {extras.neighbor_leeway = 0.2;}
  if (extras.iterations === undefined) {extras.iterations = 30;}
  if (extras.change_leeway === undefined) {extras.change_leeway = 1.015;}
  if (extras.interval_quality === undefined) {
    extras.interval_quality = function (interval, imperfection, first, second) {
      var overlapping = (first.start <second.start + second.duration - extras.neighbor_leeway) && (second.start <first.start + first.duration - extras.neighbor_leeway);
      var badness = interval.limit;
      if (interval.limit === 1) {badness = 7;}
      if (overlapping) {
        badness *= 2;
        imperfection *= 20;
      }
      return -imperfection - badness*badness*badness;
    }
  }
  notes.forEach(function(note) {
    note.neighbors = [];
    note.original_frequency = note.frequency = note_frequency (note);
  });
  notes.forEach(function(first) {
    notes.forEach(function(second) {
      if (first == second) {return;}
      if (first.start <= second.start + second.duration + extras.neighbor_leeway && second.start <= first.start + first.duration + extras.neighbor_leeway) {
        first.neighbors.push (second);
      }
    });
  });
  
  function pair_quality (first, second) {
    var frequency = first.frequency/second.frequency;
    while (frequency <1.0) {frequency *= 2;}
    while (frequency >2.0) {frequency /= 2;}
    var closest = closest_interval (frequency);
    return extras.interval_quality (closest, Math.abs (Math.log (frequency/closest.frequency)), first, second);
  }
  function compute_quality (first) {
    var total_quality = 0;
    first.neighbors.forEach(function(second) {
      total_quality += pair_quality (first, second);
    });
    return total_quality;
  }
  notes.forEach(function(note) {
    note.quality = compute_quality (note);
  });
  
  var adjustment_scale = Math.log (extras.change_leeway)*2;
  var adjustment_scale_final = Math.log (1.001);
  var adjustment_scale_decay = Math.pow(adjustment_scale_final/adjustment_scale, 1/extras.iterations);
  for (var iteration = 0; iteration <extras.iterations;++iteration) {
   notes.forEach(function(note) {
    var old_frequency = note.frequency;
    var new_frequency = note.frequency;
    var leeway = note.change_leeway || extras.change_leeway;
    var scale = Math.min (adjustment_scale, Math.log (leeway));
    var adjustment = Math.exp(scale*(Math.random ()*2-1.0));
    new_frequency *= adjustment;
    if (new_frequency < note.original_frequency*leeway && new_frequency*leeway > note.original_frequency) {
      note.frequency = new_frequency;
      var new_quality = compute_quality (note);
      if (new_quality >note.quality) {
        note.quality = new_quality;
      }
      else {
        note.frequency = old_frequency;
      }
    }
   });
   adjustment_scale *= adjustment_scale_decay;
  }
  notes.forEach(function(note) {
    var pitch_frequency = note.original_frequency;
    while (note.frequency/pitch_frequency >semitone_ratio) {pitch_frequency *= semitone_ratio; note.pitch += 1;}
    while (pitch_frequency/note.frequency >semitone_ratio) {pitch_frequency /= semitone_ratio; note.pitch -= 1;}
    note.speed = (note.speed || 1)*note.frequency/pitch_frequency;
  });
console.log(notes)
}

optimize


