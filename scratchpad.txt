string ='''

'''

index = 0
def transform (match):
  nonlocal index
  if match.group (0) == "voldemort's":
    index = index + 1
    return match.group (0)
  else:
    return "voldemorts-children/" +str (index)
  
import re
print (re.sub (r"voldemort's|voldemorts-children/\d+", transform, string ))



import shutil
import re
import subprocess

with open ("./game.svg", "r") as file:
  text = file.readall ()
  text_identifiers = [match.group (1) for match in re. finditer (r'''<text.*?id=".+?)".*?(?<!>R|>L)</tspan></text>''')]
shutil.copy ("./game.svg", "./without_text.svg")
shutil.copy ("./game.svg", "./with_only_text.svg")

subprocess.run (["inkscape", "./without_text.svg"] + ["--select=" + ID for ID in text_identifiers] + ["--verb=EditDelete","--verb=FileSave"])
subprocess.run (["inkscape", "./with_only_text.svg"] + ["--select=" + ID for ID in text_identifiers] + ["--verb=EditInvert","--verb=EditDelete","--verb=FileSave"])


global fake_comment_id
fake_comment_id = ''
def put_in_hover_boxes(comment_list):
  if len(comment_list) == 0:
    return ''
  global fake_comment_id
  fake_comment_id = fake_comment_id+'i'
  return '<div class="comment_hover_box"><div class="whole_comment_hover_marker">'+comment_list[0]+'</div>'+put_in_hover_boxes(comment_list[1:])+'</div>'

def fake_comments(tree_structure):
  return put_in_hover_boxes(['<article><div class="user_comment" id='+fake_comment_id+'><div class="comment_body_hover_marker"><div class="comment_body_outer"><div class="comment_body"><h3>SomeUser5098 <a href="#'+fake_comment_id+'">wrote</a>:</h3>I GOT STUFF TO SAY</div></div></div>'+fake_comments(foo)+'</div></article>' for foo in tree_structure])

fake_comment_html = '''<section>
  <div class="comments_section">
    <h2 class="comments_title">Comments</h2>
    <div class="all_comments">'''+fake_comments([[[],[[[],[[[]],[]],[]]]],[],[[[],[[[],[[[]],[]],[]]]]]])+'''</div>
  </div>
</section>'''
  
def add_fake_comments(html):
  return re.sub(re.escape(utils.inline_separator+'<a href="">Comments&nbsp;(14)</a>'), fake_comment_html, html)




codecophony:

main thread:
only this thread can interact with the UI.
Only this thread can interact with web audio.
Forbidden from cloning large arrays to or from other threads or indexedDB, although it may transfer them with other threads.
Records audio input, and also clone-messages it live (incrementally, in small chunks) to Trusted Worker.
The UI gives information about tasks that have been allocated to other threads and not yet completed.

Trusted Worker:
Able to interact with indexedDB.
New audio buffers are sent here to be analyzed/rendered; analysis is sent incrementally to the main thread to be shown to the user
Answers requests from Sandbox Worker for stuff from indexedDB.
Fetches MIDIJS instruments and stores them in indexedDB.

Sandbox Worker:
runs user scripts.

render_notes:
first iterates through the notes, requesting all instruments and sorting them by start time.
Incrementally transfers the rendered audio to Trusted Worker for analysis.
You may specify a "focal time" to begin the rendering at, so that you can get prompt updates if you're tweaking the middle of a long piece of music. Also maybe we should be more incremental in general? Render_notes could examine the previous collection of notes and only re-render parts that have changed. The "focal time" feature is still useful if you, say, transpose the entire piece.



"invariants" (things which should become true if you leave the scripts alone long enough to do them):
manually created user data is in indexedDB
MIDIJS instruments which are referenced by any project are in indexedDB
MIDIJS instruments which are NOT referenced by any project are NOT in indexedDB
the UI reflects the data in indexedDB










var notes = [];
for (var whatever = 0; whatever <100;++whatever) {
  notes.push ({
    start: Math.floor (Math.random()*30)/3,
    duration: Math.random()*0.4 + 0.2,
    pitch: Math.floor (Math.random()*12)-6,
    instrument: "trumpet",
    volume: 1,
  });
}
items.optimize (notes, {change_leeway:2, iterations:510, interval_quality:
  function (interval, imperfection, first, second) {
    var center = (first.start + second.start)/2;
    var target = 11 - center;
    var reward = -Math.abs (interval.limit - target)*Math.abs (interval.limit - target);
    return reward - imperfection;
  }
});
items.example_notes = notes;

var example_sequence = items.example_sequence = codecophony.render_notes (notes);



var notes = codecophony.scrawl (
  `with instrument trumpet pitch -10 duration 0.28 change_leeway 1.015

play 0 then 2 then 3 then 5 then 7 then 8 then 10 then 12
then 0 then 2 then 3 then 5 then 7 then 8 then 10 then 12
then 0 then 2 then 3 then 5 then 7 then 8 then 10 then 12
then 0 then 2 then 3 then 5 then 7 then 8 then 10 then 12

`
)
for (var scale = 1; scale <32;scale*=2) {
  for (var position = 0; position <32; position += scale) {
    notes.push ({
      start: position/4,
      duration: scale/4,
      pitch: 0,//Math.floor (Math.random()*12)-6,
      instrument: "trumpet",
      volume: 0.2,
    });
  }
}

items.optimize (notes, {change_leeway:2, iterations:510,interval_quality: function (interval, imperfection, first, second) {
      var overlapping = (first.start <second.start + second.duration - 0.2) && (second.start <first.start + first.duration - 0.2);
      var badness = interval.limit;
      
      if (overlapping) {
        badness = badness*badness;
        imperfection *= 20;
      }
else if (badness == 9 || badness == 17) {
badness = -10
}
if (interval.limit === 1) {badness = 7999999;}
      var result =-imperfection - badness;
      return result*first.volume*second.volume;
    }
});
items.example_notes3 = notes;

var example_sequence = items.example_sequence3 = codecophony.render_notes (notes);





var reference_intervals = [];

// inefficient algorithm to generate the lookup table
// specifically, we want to be able to look up, for any interval, the interval with the smallest odd-limit that is within the just-noticeable-difference (about 0.6%, according to Wikipedia) of the query.

var JND = 1.006;
var semitone_ratio = Math.pow (2, 1/12) ;

function closest_intervals_impl (frequency) {
  var index =_.sortedIndexBy (reference_intervals, {frequency}, (interval) => interval.frequency);
  var previous = reference_intervals [index - 1];
  var next = reference_intervals [index];
  
  if (!previous) {previous = {limit: 1, numerator: 1, denominator: 1, frequency: 1.0};}
  if (!next) {next = {limit: 1, numerator: 1, denominator: 1, frequency: 2.0};}
  
  return {index, previous, next};
}

var limit = 3;
while (limit < 40) {
  var done = reference_intervals.length >0;
  reference_intervals.forEach(function(interval, index) {
    var next = reference_intervals [index + 1];
    if (next && next.frequency > interval.frequency*JND*JND) {done = false;}
    if (!next && 2.0 > interval.frequency*JND*JND) {done = false;}
  });
  if (done) {break;}
  
  
  function consider (limit, numerator, denominator) {
    var frequency = numerator/denominator;
    while (frequency <1.0) {frequency *= 2;}
    while (frequency >2.0) {frequency /= 2;}
    var interval = {limit, numerator, denominator, frequency};
    
    var nearby = closest_intervals_impl (frequency);
    
    // try not to duplicate intervals by ruling out ones that are VERY close
    // I could instead rule out intervals that are not introduced form, but I can't bother
    if (nearby.previous.frequency*1.00001 > frequency && frequency*1.00001 > nearby.previous.frequency) {return;}
    if (nearby.next.frequency*1.00001 > frequency && frequency*1.00001 > nearby.next.frequency) {return;}
    
    //rule out intervals that are already in the shadow of others
    if (nearby.next.frequency < nearby.previous.frequency*JND*JND) {return;}
      
    reference_intervals.splice (nearby.index, 0, interval);
  }
  for (var other = 1; other <= limit; other += 2) {
    consider (limit, limit, other);
    consider (limit, other, limit);
  }
  
  limit += 2;
}

function closest_interval (frequency) {
  while (frequency <1.0) {frequency *= 2;}
  while (frequency >2.0) {frequency /= 2;}
  
  var nearby = closest_intervals_impl (frequency);
  if (frequency/nearby.previous.frequency < nearby.frequency/frequency) {
    return nearby.previous;
  }
  else {
    return nearby.next;
  }
}

function note_frequency (note) {
  return 261.626 * Math.pow (2, note.pitch / 12) * (note.speed || 1);
}

function optimize (notes, extras) {
  if (!extras) {extras={};}
  if (extras.neighbor_leeway === undefined) {extras.neighbor_leeway = 0.2;}
  if (extras.iterations === undefined) {extras.iterations = 30;}
  if (extras.change_leeway === undefined) {extras.change_leeway = 1.015;}
  if (extras.interval_quality === undefined) {
    extras.interval_quality = function (interval, imperfection, first, second) {
      var overlapping = (first.start <second.start + second.duration - extras.neighbor_leeway) && (second.start <first.start + first.duration - extras.neighbor_leeway);
      var badness = interval.limit;
      if (interval.limit === 1) {badness = 7;}
      if (overlapping) {
        badness *= 2;
        imperfection *= 20;
      }
      return -imperfection - badness*badness*badness;
    }
  }
  notes.forEach(function(note) {
    note.neighbors = [];
    note.original_frequency = note.frequency = note_frequency (note);
  });
  notes.forEach(function(first) {
    notes.forEach(function(second) {
      if (first == second) {return;}
      if (first.start <= second.start + second.duration + extras.neighbor_leeway && second.start <= first.start + first.duration + extras.neighbor_leeway) {
        first.neighbors.push (second);
      }
    });
  });
  
  function pair_quality (first, second) {
    var frequency = first.frequency/second.frequency;
    while (frequency <1.0) {frequency *= 2;}
    while (frequency >2.0) {frequency /= 2;}
    var closest = closest_interval (frequency);
    return extras.interval_quality (closest, Math.abs (Math.log (frequency/closest.frequency)), first, second);
  }
  function compute_quality (first) {
    var total_quality = 0;
    first.neighbors.forEach(function(second) {
      total_quality += pair_quality (first, second);
    });
    return total_quality;
  }
  notes.forEach(function(note) {
    note.quality = compute_quality (note);
  });
  
  var adjustment_scale = Math.log (extras.change_leeway)*2;
  var adjustment_scale_final = Math.log (1.001);
  var adjustment_scale_decay = Math.pow(adjustment_scale_final/adjustment_scale, 1/extras.iterations);
  for (var iteration = 0; iteration <extras.iterations;++iteration) {
   notes.forEach(function(note) {
    var old_frequency = note.frequency;
    var new_frequency = note.frequency;
    var leeway = note.change_leeway || extras.change_leeway;
    var scale = Math.min (adjustment_scale, Math.log (leeway));
    var adjustment = Math.exp(scale*(Math.random ()*2-1.0));
    new_frequency *= adjustment;
    if (new_frequency < note.original_frequency*leeway && new_frequency*leeway > note.original_frequency) {
      note.frequency = new_frequency;
      var new_quality = compute_quality (note);
      if (new_quality >note.quality) {
        note.quality = new_quality;
      }
      else {
        note.frequency = old_frequency;
      }
    }
   });
   adjustment_scale *= adjustment_scale_decay;
  }
  notes.forEach(function(note) {
    var pitch_frequency = note.original_frequency;
    while (note.frequency/pitch_frequency >semitone_ratio) {pitch_frequency *= semitone_ratio; note.pitch += 1;}
    while (pitch_frequency/note.frequency >semitone_ratio) {pitch_frequency /= semitone_ratio; note.pitch -= 1;}
    note.speed = (note.speed || 1)*note.frequency/pitch_frequency;
  });
console.log(notes)
}

optimize


