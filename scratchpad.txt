
import math

cardboard_width = 0.157
padding_width = 3/8;


box_length = 5.75
box_width = 4.72 #4.75
box_outer_length = box_length + cardboard_width*2
box_outer_width = box_width + cardboard_width*2

fan_depth = 1
fan_outer_width = 4.72
fan_inner_width = 4.5
fan_inner_radius = fan_inner_width/2

filter_depth = 0.5
filter_outer_length = 5.75
filter_outer_width = 3+15/16
filter_border = 3/16
filter_inner_length = filter_outer_length - filter_border*2
filter_inner_width = filter_outer_width - filter_border*2
filter_grip_width = (box_width - filter_inner_width)/2

filter_placement = (box_width - filter_outer_width)/2
fan_placement = (box_length - fan_outer_width)/2

support_depth = 0.25

box_depth = support_depth + cardboard_width + fan_depth + cardboard_width + filter_depth

head_width = 6.25
head_length = 7.5

turn = math.pi*2

next_id = 40000
close = "z"

def draw_path (path):
  first = "M"
  components = []
  for location in path:
    if location == "z":
      components.append ("z")
      first = "M"
    else:
      #convert in to pt and position within bounds
      components.append (first + " " + str (location [0]*72 + 14.173) + " " + str (location [1]*72 + 14.173))
      first = "L"
  global next_id
  next_id = next_id + 1
  return '''<path
       style="opacity:1;fill:none;fill-opacity:1;fill-rule:nonzero;stroke:#0000ff;stroke-width:0.0283465;stroke-linecap:butt;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
       d="'''+ " ".join (components) +''' "
       id="'''+ str (next_id) +'''" />'''

def split_path (path):
  previous = None
  components = []
  origin = None
  for location in path:
    print (location, origin)
    if location == close:
      components.append ([previous, origin])
      origin = None
      previous = None
    else:
      if previous is not None:
        components.append ([previous, location])
      previous = location
      if origin is None:
        origin = location
  return components

def rectangle_center (first, second, width, height):
  first = first + horizontal_default
  second = second + vertical_default
  return [(first - width/2, second - height/2), (first + width/2, second - height/2), (first + width/2, second + height/2), (first - width/2, second + height/2), close]

vertical_default = 0
def rectangle_advance_vertical (first, second, width, height):
  global vertical_default
  result = rectangle_corner(first, second, width, height)
  vertical_default = vertical_default + height
  return result
horizontal_default = 0
def rectangle_advance_horizontal (first, second, width, height):
  global horizontal_default
  result = rectangle_corner(first, second, width, height)
  horizontal_default = horizontal_default + width
  return result

def rectangle_corner (first, second, width, height):
  first = first + horizontal_default
  second = second + vertical_default
  return [(first, second), (first + width, second), (first + width, second + height), (first, second + height), close]

def oval (first, second, width, height, segments, parity, inscribed):
  first = first + horizontal_default
  second = second + vertical_default
  inaccuracy = 1 if inscribed else math.cos (turn*0.5/segments);
  result = []
  for index in range (0, segments):
    angle = turn*(index + parity)/segments
    result.append ((first + width*math.cos (angle)/inaccuracy, second + height*math.sin (angle)/inaccuracy))
  result.append (close)
  return result
  
paths = [
  #rectangle_corner (0, 0, box_width + box_length + box_width + box_length, box_depth),
  [(0, 0), (0, box_depth + filter_grip_width), (box_length, box_depth + filter_grip_width), (box_length, box_depth), (box_length + box_width, box_depth), (box_length + box_width, box_depth + filter_grip_width),(box_length + box_width + box_length, box_depth + filter_grip_width),(box_length + box_width + box_length, box_depth), (box_length + box_width + box_length + box_width, box_depth), (box_length + box_width + box_length + box_width, 0), close],
]

horizontal_default = 0
vertical_default = box_depth + filter_grip_width

supports = [
  rectangle_advance_vertical (0, 0, box_length, support_depth),
  rectangle_advance_vertical (0, 0, box_length, support_depth),
  rectangle_advance_vertical (0, 0, box_length, fan_depth - cardboard_width),
  rectangle_advance_vertical (0, 0, box_length, fan_depth - cardboard_width),  
  rectangle_advance_vertical (0, 0, box_length, filter_depth - cardboard_width),
  rectangle_advance_vertical (0, 0, box_length, filter_depth - cardboard_width),
]

horizontal_default = box_length
vertical_default = box_depth + filter_grip_width
placements = [
  rectangle_advance_horizontal (0, 0, fan_placement, box_width),
  rectangle_advance_horizontal (0, 0, fan_placement, box_width),
  rectangle_advance_horizontal (0, 0, filter_placement, box_length),
  rectangle_advance_horizontal (0, 0, filter_placement, box_length),
]

gates = [
  oval (box_width/2, box_length/2, fan_inner_width/2, fan_inner_width/2, 8, 0.5, False)[-2::-1] + [close] + rectangle_advance_horizontal (0, 0, box_width, box_length),
  rectangle_center (box_width/2, box_length/2, filter_inner_width, fan_inner_width)[-2::-1] + [close] + rectangle_advance_horizontal (0, 0, box_width, box_length),
]

diagonal = []
horizontal = []
vertical = []

for path in (paths + supports + placements + gates):
  for component in split_path (path):
    (horizontal if component[0] [1] == component[1] [1] else vertical if component[0] [0] == component[1] [0] else diagonal).append (component)


for (list, equal_dimension, different_dimension) in [(horizontal, 1, 0), (vertical, 0, 1)]:
  for index in range (len (list)):
    if list[index] [0] [different_dimension] >list[index] [1] [different_dimension]:
      list[index] = (list[index] [1], list[index] [0])
  
  list.sort (key = lambda component: component [0] [equal_dimension] + 0.00001*component [0] [different_dimension])
    
  index = 0
  while index <len (list) - 1:
    if abs(list[index] [0] [equal_dimension] - list [index + 1] [0] [equal_dimension]) < 0.0001 and list [index] [1] [different_dimension] >= -0.0001 + list [index + 1] [0] [different_dimension]:
      removed = list.pop (index + 1)
      list [index] = (list [index] [0], removed [1])
    else:
      index = index + 1
      

print ("\n".join ([draw_path (path) for path in (horizontal + vertical + diagonal)]))

       
#junk junk junk
#(Dragon sometimes freezes up, and I think it happens more when it's near the end of the file, soâ€¦)
